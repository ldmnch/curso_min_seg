---
title: "Clase 6 - Mapas e interactividad"
author: "Domenech Burin, Laia"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
date: "`r format(Sys.time(), '%d %B, %Y')`"
theme: Boadilla
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, collapse=TRUE, highlight=TRUE, paged.print=FALSE, prompt=TRUE, strip.white=FALSE)
```

## Mirando al espacio

Los mapas son una unidad visual que puede reconocer prácticamente la totalidad de la población de una región determinada. La visualización de mapas  y el análisis espacial solía estar reservado para especialistas, debido a la complejidad y costo de este tipo de procesos. Pero durante las dos últimas décadas la tecnología digital cambió el panorama. Una dramática caída en el costo asociado a adquirir y procesar información geográfica (pensemos en satélites y computadoras multiplicándose y bajando de precio) dio paso al mapa digital como herramienta universal. 

Hoy en día, hacer mapas resulta algo muy fácil. Existen cada vez más repositorios con información georreferenciada de acceso publico -datasets que incluyen información precisa sobre su ubicación geográfica. Al mismo tiempo, maduran y se hacen más fáciles de usar las herramientas para análisis y visualización espacial. 

En R contamos con varios paquete de funciones que permiten manipular información espacial con facilidad. A continuación vamos a aprender a combinarlos con las herramientas que ya hemos aprendido, para hacer análisis geográfico y crear nuestros propios mapas.

### Geometrías

Los archivos de datos geográficos relacionados con fenómenos sociales (datos de cosas que somos y hacemos los humanos, como composición de población, trazado de rutas, ubicación de hospitales, etc) suelen ser de tipo vectorial. Los datos vectoriales expresan la posición y extensión de cosas mediante geometrías, que pueden ser de puntos, de líneas, o de polígonos. En la jerga de los sistemas de información geográfica, se les llama "capas" (_layers_) a los archivos que contienen estas geometrías, y en ese sentido se hablar de combinar capas para crear mapas.

![](./img/puntos_lineas_polis.png){width=60%}

* Un archivo geográfico con geometría de __puntos__ se utiliza para marcar __posiciones__: por ejemplo, puntos que señalen la ubicación de hospitales.

* La geometría de __líneas__ permite mostrar __recorridos__: como por ejemplo la extensión de ríos, de autopistas o de calles. 

* Los __polígonos__ se usan cuando hay que representar __superficies__: el territorio de barrios, provincias o países; el terreno ocupado por parques y plazas, la extensión de parcelas, los límites de áreas especiales como un coto de caza, etc.

### Los datos georreferenciados

Los datos georeferenciados reciben su nombre justamente porque están vinculados a locaciones en el mundo físico. Estaciones de subte, hogares, reservas ecológicas, cualquier lugar que exista. Si bien hoy en día es más fácil que nunca trabajar con este tipo de datos, tienen algunas complicaciones. 

La principal de ellas está vinculada con la forma esférica irregular de la Tierra. No es un círculo perfecto, sino que está "achatada" en los polos, dificultando la matemática necesaria para comparar posiciones y medir distancias. Esta forma hace que sea imposible de representar a la exactitud en un plano de dos dimensiones. El proceso a través del cual desplegamos la tierra en dos para dibujarla en un mapa plano es la **proyección**.  

Las proyecciones cartográficas son instrucciones para traducir a un plano la disposición de puntos ubicados en la esfera terrestre. Toman como base los CRS: un sistema de números que definen ubicaciones sobre la superficie de la Tierra. El más conocido es el que usa latitud y longitud, para definir posiciones en los ejes norte-sur y este-oeste.

Inevitablemente, las proyecciones van a introducir distorsiones porque uan superficie curva no puede ser proyectada con exactitud en una superficie plana. Más específicamente, la proyección puede preservar ángulos o áreas pero no ambas. Existen muchísimas proyecciones distintas, cada una pensada para minimizar alguno de los tipos de distorsión, o para encontrar una solución de compromiso que los balancee.

La proyección más famosa y utilizada es la Mercator, que fue desarrollada en el siglo 16 para la navegación marítima. Esta proyección tiene como ventaja que no distorsiona las direcciones, por lo que permite fijar un rumbo de navegación consultando el mapa. Su principal problema es que produce una distorsión notable en las áreas cercanas a los polos: Groenlandia aparenta el mismo tamaño que toda África, cuando en realidad tiene sólo un quinceavo de su superficie. 

Sin embargo, Google la eligió para sus mapas en línea, y por razones de compatibilidad otros proveedores de mapas digitales la adoptaron también. Así, y para entendible irritación de especialistas en geografía, Mercator se convirtió en el estándar de facto para aplicaciones geográficas y mapas en la web.

![](./img/mercator.png){width=50%}

En la práctica, si trabajamos en forma frecuente con archivos georreferenciados vamos a sufrir tarde o temprano de problemas de coordenadas o proyección. El más común de ellos: tener una fuentes de datos geográficos que no podemos comparar con otras, porque desconocemos el sistema de coordenadas que se usó para crearla; es decir, no podemos saber a que posición sobre el planeta corresponde cada observación en los datos.

### Importando la data

Otro problema asociado a trabajar con datos geográficos es el de los formatos de archivo. El formato más común es el denominado “shapefile”, inventado por la empresa ESRI (los creadores del software ArcGIS). Es un formato incómodo porque guarda la información en varios archivos distintos, que suelen ser combinados en un archivo .zip para su distribución. Un inconveniente aún mayor es que los nombres de las variables en un shapefile deben tener 10 caracteres o menos, lo que facilita el uso de abreviaturas ininteligibles. A pesar de éstos y otros detrimentos, el formato es tan común que se ha vuelto sinónimo de archivo con información geográfica, y resiste a pesar de los esfuerzos por reemplazarlo con alternativas más modernas. Una de ellas es “GeoJSON”, un estándar abierto que corrige los dos inconvenientes mencionados antes. Para nuestros ejercicios usaremos datos geográficos en esta último formato.

Vamos a continuar trabajando con `ggplot2`, pero además vamos a incluir el paquete `sf` que sirve para trabajar específicamente con datos georeferenciados. 

```{r}
library(tidyverse)
library(ggplot2)
library(sf)
```
Practicaremos con datos georeferenciados en polígonos: los departamentos de la Provincia de Buenos Aires. 

```{r}
pba_geo <- read_sf("./data/deptos_pba.geojson")
```

Veamos cómo está compuesto este dataframe:

```{r}
head(pba_geo)
```
La data contiene información básica de cada provincia. Sin embargo, van a ver tiene una columna particular, cuyo formato no habíamos visto aún: `geometry`. Esta columna tiene la información de una serie de puntos que trazan un **polígono**. En otras palabras, contiene la forma de cada provincia Por esto esta variable será fundamental para realizar mapas en R, es el insumo básico de donde el programa saca la información para trazarlos. 

A partir de esto, graficar un mapa es tan simple como usar dos líneas de ggplot con la geometría `geom_sf`. 

```{r}
ggplot(pba_geo)+
        geom_sf()
```

### Información en mapas

Con frecuencia vemos información presentada en mapas. Un ejemplo de ellos es el [mapa del delito](https://mapa.seguridadciudad.gob.ar/) de CABA, otro es el [mapa de accesibilidad](https://acceso.shinyapps.io/mapa/) de factor~data.  Detengámonos un segundo a ver, ¿cuáles son las propiedades estéticas utilizadas para mostrar la información?

La forma más común de mostrar información geográfica es a través de **mapas coropléticos**, donde se colorean regiones individualmente de acuerdo a la dimensión de la información que se quiere mostrar. Para hacerlo, nada más hay que asignarle al atributo `fill`la dimensión que queremos plasmar. 
Vamos a agregarle capas de información a nuestro mapa. Por ejemplo, supongamos que queremos ver en el mapa qué departamentos tuvieron una mayor cantidad de homicidios dolosos en el año 2020. Para esto podemos usar la base de datos con la que estuvimos trabajando las últimas clases. Vamos a filtrarla e importar los casos que nos interesan.

```{r}
df <- readxl::read_xlsx("data/Integrado_HD_base_usuaria_2017-2020.xlsx")

#Formato
pba <- df %>% filter(provincia == "BUENOS AIRES") 

pba <- pba %>% filter(departamento != "Departamento sin determinar")

pba <- pba %>% filter(anio ==2020)
```

Luego, joineamos las dos bases. Una cosa **muy importante** es que siempre hay que poner la base con las geometrías a la izquierda, de lo contrario la columna `geometry` pierde el formato. 

```{r}
#Join
pba_geo <- pba_geo %>% left_join(pba, by=c("in1"="Cod_INDEC"))
```

Ahora podemos hacer lo que ya sabemos: agrupar y contar los casos por `Id_hecho`.

```{r}
tb1 <- pba_geo%>%
        group_by(anio, nam)%>%
        summarise(n=n_distinct(Id_hecho, na.rm = TRUE)) 
```
Como estamos trabajando el gráfico con `ggplot`, podemos pasarle el atributo estético `n` al parámetro `fill` para que los polígonos se pinten según la frecuencia de casos.

```{r}
ggplot(tb1, aes(fill=n))+
        geom_sf()
```


Acá vemos algo, pero las líneas grises que dibujan cada polígono nos dificultan ver los datos con claridad. Vamos a sacar estas líneas asignándole al parámetro `color = NA`:

```{r}
ggplot(tb1)+
        geom_sf(aes(fill = n), color = NA)
```

En este mapa, La Matanza destaca como el departamento con mayor cantidad de homicidios en 2020. Sin embargo, algo que no hemos mencionado aún es la importancia de "normalizar" las variables antes de mostrarlas en un mapa. En general, los lugares más grandes van a contener dentro "más" de cualquier variable que los lugares pequeños (sean personas, comercios o accidentes). En este sentido, es de esperar que La Matanza registre más incidentes que los demás departamentos ya que de acuerdo con las proyecciones poblacionales del último censo tiene 2.281.194 de habitantes. Lo que sería más útil aquí es presentar la relación entre homicidios y la cantidad de habitantes. 

Por eso vamos a incorporar un dataframe que nos de adicional: las proyecciones poblacionales por departamento de 2020.

```{r}
proyecciones <- readxl::read_excel("data/proy_pba.xls")

proyecciones <- proyecciones %>% mutate(Proyecciones_2020 = as.numeric(Proyecciones_2020))

pba_geo <- pba_geo %>% 
        left_join(proyecciones, by = c("nam" = "Partido"))
```

Ahora sí, vamos a agrupar por año, departamento y tamaño de la población.

```{r}
tb2 <- pba_geo%>%
        group_by(anio, nam, Proyecciones_2020)%>%
        summarise(n=n_distinct(Id_hecho, na.rm = TRUE)) 
```
Y lo vamos a graficar. 

```{r}
ggplot(tb2)+
        geom_sf(aes(fill = n/Proyecciones_2020), color = NA)
```

Este último gráfico representa de forma mucho mas precisa la distribución homicidios dolosos por habitante en la provincia. Pero tenemos una mejora más por realizar: elegir una escala de color que haga más legible el gráfico, ayudando al ojo a diferenciar las áreas donde la densidad es particularmente alta o baja. Apelamos a ["viridis"](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html), una escala diseñada para ser fácil de interpretar... y lucir bien de paso. Para usar virids, agregamos `scale_fill_viridis_d()` cuando se muestra una variable categórica, y `scale_fill_viridis_c() `cuando se trata de una variable continua, nuestro caso en este momento.

```{r}
library(viridis)

ggplot(tb2)+
        geom_sf(aes(fill = n/Proyecciones_2020), color = NA)+
        scale_fill_viridis_c()+
        labs(title = "Provincia de Buenos Aires",
             subtitle = "Homicidios dolosos en 2020",
             fill = "HD/Cant. habitantes")+
        theme_minimal()
```
Vemos que parecen otros departamentos en tonos verde agua y amarilllo que nos llaman la atención. A priori podemos ver que los departamentos de Pellegrini, San Pedro, Baradero o Capitán Sarmiento parecen tener una cantidad relativamente más alta de homicidios que los demás departamentos.

Sin embargo, se nos hace un poco difícil ver departamentos más pequeños -como por ejemplo los de la costa. Podríamos hacer zoom en un gráfico estático definiendo coordenadas en los límites de los ejes x e y. Pero, también podemos hacer una alternativa interactiva. 

### Interactividad en R 

Además de las funciones incluidas en el lenguaje, y de la "gramática" para realizar todo tipo de gráficos que ofrece `ggplot2`, podemos agregar a nuestro repertorio paquetes adicionales que realizan visualizaciones específicas. En la vertiente de interactividad, son notables los paquetes reunidos bajo el nombre de [htmlwidgets](http://gallery.htmlwidgets.org/), que generan visualizaciones dinámicas con una gran variedad de estilos y recursos.

La particularidad de los *htmlwidgets* es que traen a `R` excelentes funciones de visualización desarrolladas en `JavaScript`. El gran fuerte de `JavaScript` es la generación de contenido interactivo para sitios web. Los paquetes reunidos en la colección *htmlwidgets* "envuelven" el código `Javascript` en instrucciones en `R`, haciendo un puente entre los dos mundos, y permitiendo generar desde `R` visualizaciones que pueden publicarse como contenido web. Para nuestros fines, vamos a concentrarnos en dos de las opciones en particular:[`leaflet`](https://rstudio.github.io/leaflet/) para mapas interactivos y [`Plotly`](https://plotly.com/r/) para convertir nuestros gráficos realizados en `ggplot2` a versiones interactivas. 

#### Mapas interactivos

Con la explosión de de popularidad de los mapas online, con Google Maps al frente, se ha vuelto habitual explorar información geográfica en entornos interactivos, que permiten al usuario desplazarse libremente por la superficie terrestre y cambiar el nivel de zoom con el que se muestran los datos. Mapas con información tan precisa como la posición de los delitos, que incluso permite ver a parcela donde han ocurrido, se beneficia en extremo de la posibilidad de variar la escala de visualización a voluntad.

Desde R es fácil proyectar nuestros datos sobre mapas interactivos, usando el paquete `leaflet`.

Lo activamos con:

```{r}
library(leaflet)
```

El uso de `leaflet` es similar al de `ggplot`; uno toma un dataframe y lo muestra mediante capas que exponen distintos aspectos de la información. Para comenzar, usemos `leaflet(tb2)`

```{r}
leaflet(tb2)
```

... y no obtuvimos mucho. Tal como pasa con `ggplot()`, si uno no define ninguna capa de visualización, el resultado es una especie de lienzo vacío.

Siguiente paso: agregar un mapa base, agregando al código la función `addTiles()`. Para sumar capas a un mapa de `leaflet` usamos " %\>% " en lugar del " + " que requiere `ggplot()`, pero el concepto es el mismo.

```{r}
leaflet(tb2)%>%
        addTiles()
```

Hasta acá, tenemos un mapa del mundo pero sin nuestros polígonos. Para ello los vamos a agregar con la función `addPolygons`. 

`leaflet` no nos permite identificar regiones en un mapa por color automáticamente, sino que requiere que creemos por nuestra cuenta una paleta de colores para aplicar a nuestros datos. suerte contamos con funciones auxiliares que nos permiten crear paletas a medida, dependiendo del tipo de datos que vamos a mostrar: `colorFactor()` para variables categóricas, `colorNumeric()` para variables numéricas, o `colorQuantile()` también para variables numéricas, pero agrupadas en cuantiles. Cualquiera de las opciones requiere al menos dos parámetros. Uno es “palette”, para definir los tonos a usar (aquí funcionan nuestros amigos viridis, magma, plasma e inferno, y también las paletas Brewer, como Set1 , Spectral o Accent). El parámetro restante es “domain”, que simplemente toma un vector con los datos que vamos a representar con la paleta. En este caso, le vamos a pasar `NULL` ya que los datos se los vamos a asignar en el mismo gráfico. 

```{r}
pal <- colorNumeric("viridis", NULL)
```

Ahora, vamos a agregarle los polígonos y agregar algunos parámetros para rellenar los polígonos y que queden bien. `fillColor = ~pal(n/Proyecciones_2020)` indica el relleno. Con `stroke = FALSE` borramos las líneas que separan los polígonos, con `smoothFactor = 0.3` suavizamos los bordes, con `fillOpacity = 0.8` transparentamos un poco el relleno. Por último, con `label = ~paste0(nam, ": ", round(n/Proyecciones_2020,2))` vamos a agregar una etiqueta que diga el valor redondeado de la relación homicidios dolosos/proyección poblacional.

```{r}
leaflet(tb2) %>% 
    addTiles() %>% 
    addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 0.8,
    fillColor = ~pal(n/Proyecciones_2020),
    label = ~paste0(nam, ": ", round(n/Proyecciones_2020,2)))
```

#### Interactividad en `ggplot`

Ahora, vamos a mostrar un ejemplo de cómo implementar interactividad en gráficos de `ggplot` con el paquete `plotly`. Vamos a activarlo:

```{r}
library(plotly)
```

Ahora solo necesitamos dos cosas:

- guardar el resultado de nuestra visualización en una variable, que llamaremos -por elegir algo- “p”
- pasar la variable que contiene la visualización a la función ggplotly, que la convertirá en una versión interactiva.

Y eso es todo. Vamos a intentarlo replicando el gráfico de víctimas provinciales por año que realizamos anteriormente:

```{r}
vict_prov_anio <- df %>% group_by(anio, provincia) %>%
         summarise(n = n_distinct(Id_hecho), #Cuento la cantidad de Id_hechos 
                   tot_vic = sum(cant_vic))%>% #Cuento la cantidad de víctimas
         ungroup()%>%
         mutate(tasa_vic = tot_vic/n) 

p <- ggplot(vict_prov_anio, aes(x = anio, y = n, color = provincia, size = tasa_vic))+
         geom_point()+
         scale_y_log10()+
         scale_color_viridis_d(option = "inferno")

ggplotly(p)
```

